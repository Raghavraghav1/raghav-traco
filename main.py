from fastapi import FastAPI, Depends, HTTPException  # HTTPException for proper error handling
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session

# Import your custom modules
from models import Product  # Pydantic model for request/response validation
from database import session, engine  # Database session and engine
import database_models  # SQLAlchemy declarative models (table definitions)

# Initialize the FastAPI app
app = FastAPI(
    title="Product Management API",
    description="A simple CRUD API for managing products",
    version="1.0.0"
)

# Configure CORS (Cross-Origin Resource Sharing)
# This allows your frontend (e.g., React on localhost:3000) to communicate with this backend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Change to ["*"] in development if needed
    allow_credentials=True,
    allow_methods=["*"],  # Allows all HTTP methods (GET, POST, PUT, DELETE, etc.)
    allow_headers=["*"],
)

# Create database tables if they don't exist
# This runs once when the app starts
database_models.Base.metadata.create_all(bind=engine)

# Sample data to seed the database (only if empty)
products = [
    Product(id=1, name="Iphone", description="Apple iPhone 14", price=999.99, quantity=10),
    Product(id=2, name="Samsung S22", description="Samsung Galaxy S22 FE", price=699.99, quantity=15),
    Product(id=3, name="Samsung S24", description="Samsung Galaxy S24 FE", price=849.99, quantity=8),
    Product(id=4, name="OnePlus 12", description="OnePlus 12 flagship", price=799.99, quantity=12),
]

# Dependency to get database session
# This ensures proper opening and closing of DB sessions for each request
def get_db():
    db = session()  # Create a new session
    try:
        yield db  # Provide the session to the endpoint
    finally:
        db.close()  # Always close the session after use


# Initialize database with sample data if it's empty
# This function runs only once at startup
def init_db():
    db = session()
    try:
        count = db.query(database_models.Product).count()
        if count == 0:  # Only seed if no products exist
            for product in products:
                # Convert Pydantic model to dict and create SQLAlchemy model instance
                db_product = database_models.Product(**product.model_dump())
                db.add(db_product)
            db.commit()  # Save all seeded products
            print("Sample products added to database.")
        else:
            print("Database already has data. Skipping seeding.")
    finally:
        db.close()

# Call the initialization function when the app starts
init_db()


# Root endpoint - simple welcome message
@app.get("/")
def greet():
    return {"message": "Welcome to Raghav's Product API ðŸš€"}


# GET all products
@app.get("/products")
def get_all_products(db: Session = Depends(get_db)):
    """
    Retrieve all products from the database.
    """
    db_products = db.query(database_models.Product).all()
    return db_products


# GET product by ID
@app.get("/products/{id}")
def get_product_by_id(id: int, db: Session = Depends(get_db)):
    """
    Retrieve a single product by its ID.
    Returns 404 if not found.
    """
    product = db.query(database_models.Product).filter(database_models.Product.id == id).first()
    if product:
        return product
    raise HTTPException(status_code=404, detail="Product not found")


# POST - Create a new product
# Note: Typically POST should be /products (no {id} in path)
@app.post("/products")
def add_product(product: Product, db: Session = Depends(get_db)):
    """
    Create a new product.
    The 'id' can be optional in the Product model (auto-generated by DB if not provided).
    """
    db_product = database_models.Product(**product.model_dump())
    db.add(db_product)
    db.commit()
    db.refresh(db_product)  # Get the newly generated ID and updated fields
    return db_product


# PUT - Update an existing product
@app.put("/products/{id}")
def update_product(id: int, product: Product, db: Session = Depends(get_db)):
    """
    Update a product by ID.
    Only updates fields provided in the request body.
    """
    db_product = db.query(database_models.Product).filter(database_models.Product.id == id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")

    # Update fields
    db_product.name = product.name
    db_product.description = product.description
    db_product.price = product.price
    db_product.quantity = product.quantity

    db.commit()
    return {"message": "Product updated successfully", "product": db_product}


# DELETE - Remove a product
@app.delete("/products/{id}")
def delete_product(id: int, db: Session = Depends(get_db)):
    """
    Delete a product by ID.
    """
    db_product = db.query(database_models.Product).filter(database_models.Product.id == id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Product not found")

    db.delete(db_product)
    db.commit()
    return {"message": "Product deleted successfully"}


# Startup event (optional - alternative way to run init_db)
# @app.on_event("startup")
# def on_startup():
#     init_db()